<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>从发布订阅模式的角度理解 Vue 的数据响应式原理</title>
  </head>
  <body>
    <script>
// 用于管理嵌套 effect 的调用栈
const effectStack = []
class ReactiveEffect {
    // 存储所有包含本 effect 的依赖集合（Set）
    // 用于实现 stop 功能时快速清理依赖
    deps = []
    constructor(fn) {
        // 包装的副作用函数（开发者传入的原始函数）
        this._fn = fn
    }
    // 执行副作用函数，并触发依赖收集
    run () {
        // 这里为什么要用try...finally呢？比如如果_fn中有错误，finally块仍然会执行，保证栈的平衡。
        try {
            // 1. 设置当前激活的 effect 为自身
            activeEffect = this;
            // 2. 压入 effect 调用栈（处理嵌套 effect 的关键）
            effectStack.push(this);
            // 3. 执行原始函数，触发响应式属性的 getter，进行依赖收集
            return this._fn(); // 返回函数执行结果（支持 computed 等场景）
        } finally {
            // 4. 无论执行是否抛出异常，确保以下清理逻辑一定执行
            effectStack.pop(); // 当前 effect 出栈
            // 5. 恢复 activeEffect 为上一个 effect（栈顶元素）或 undefined
            activeEffect = effectStack.length > 0 ? effectStack[effectStack.length - 1] : undefined;
        }
    }
    // 停止当前 effect 的响应式追踪
    stop () {
      // 遍历所有关联的依赖集合，从中删除本 effect
      this.deps.forEach(dep => dep.delete(this))
    }
} 
// 订阅者存储中心
const targetMap  = new WeakMap()
  // 添加订阅者
function track(target, key) {
    let depsMap = targetMap.get(target)
    if (!depsMap) {
        depsMap = new Map()
        targetMap.set(target, depsMap)
    }
    let deps = depsMap.get(key)
    if (!deps) {
      deps = new Set()
      depsMap.set(key, deps)
    }
    if (activeEffect) {
        deps.add(activeEffect)
        activeEffect.deps.push(deps)
    }
}
  // 通知订阅者
function trigger(target, key) {
    const depsMap = targetMap.get(target)
    if (!depsMap) return
    const effects = depsMap.get(key)
    effects && effects.forEach(dep => dep.run())
}

let activeEffect
// reactive
function reactive(data) {
    return new Proxy(data, {
        get(target, key) {
            // 存在依赖就把依赖收集到依赖存储中心
            track(target, key)
            return Reflect.get(target, key) 
        },
        set(target, key, val) {
            const result = Reflect.set(target, key, val)
            // 值更新了，就需要去把依赖存储中心中的依赖全部重新执行一遍
            trigger(target, key)
            return result
        }
    })
}

function effect(fn) {
    const _effect = new ReactiveEffect(fn)
    _effect.run()
    const runner = _effect.run.bind(_effect)
    runner.effect = _effect
    return runner 
}

window.state = reactive({ parent: 'parent', child: 'child' })

effect(() => {
    effect(() => {
        console.log(`我是子组件：${state.child}`)
    })
  console.log(`我是父组件：${state.parent}`)
})



</script>
  <body>
</html>